{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tamar/Desktop/autamubilismo/studio/node_modules/%40mux/mux-player-react/dist/index.mjs/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const MaxResolution = registerClientReference(\n    function() { throw new Error(\"Attempted to call MaxResolution() from the server but MaxResolution is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs <module evaluation>\",\n    \"MaxResolution\",\n);\nexport const MediaError = registerClientReference(\n    function() { throw new Error(\"Attempted to call MediaError() from the server but MediaError is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs <module evaluation>\",\n    \"MediaError\",\n);\nexport const MinResolution = registerClientReference(\n    function() { throw new Error(\"Attempted to call MinResolution() from the server but MinResolution is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs <module evaluation>\",\n    \"MinResolution\",\n);\nexport const RenditionOrder = registerClientReference(\n    function() { throw new Error(\"Attempted to call RenditionOrder() from the server but RenditionOrder is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs <module evaluation>\",\n    \"RenditionOrder\",\n);\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs <module evaluation>\",\n    \"default\",\n);\nexport const generatePlayerInitTime = registerClientReference(\n    function() { throw new Error(\"Attempted to call generatePlayerInitTime() from the server but generatePlayerInitTime is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs <module evaluation>\",\n    \"generatePlayerInitTime\",\n);\nexport const playerSoftwareName = registerClientReference(\n    function() { throw new Error(\"Attempted to call playerSoftwareName() from the server but playerSoftwareName is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs <module evaluation>\",\n    \"playerSoftwareName\",\n);\nexport const playerSoftwareVersion = registerClientReference(\n    function() { throw new Error(\"Attempted to call playerSoftwareVersion() from the server but playerSoftwareVersion is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs <module evaluation>\",\n    \"playerSoftwareVersion\",\n);\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,uEAAuE;AACvE;;AACO,MAAM,gBAAgB,IAAA,sTAAuB,EAChD;IAAa,MAAM,IAAI,MAAM;AAA0O,GACvQ,4HACA;AAEG,MAAM,aAAa,IAAA,sTAAuB,EAC7C;IAAa,MAAM,IAAI,MAAM;AAAoO,GACjQ,4HACA;AAEG,MAAM,gBAAgB,IAAA,sTAAuB,EAChD;IAAa,MAAM,IAAI,MAAM;AAA0O,GACvQ,4HACA;AAEG,MAAM,iBAAiB,IAAA,sTAAuB,EACjD;IAAa,MAAM,IAAI,MAAM;AAA4O,GACzQ,4HACA;uCAEW,IAAA,sTAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAA8V,GAC3X,4HACA;AAEG,MAAM,yBAAyB,IAAA,sTAAuB,EACzD;IAAa,MAAM,IAAI,MAAM;AAA4P,GACzR,4HACA;AAEG,MAAM,qBAAqB,IAAA,sTAAuB,EACrD;IAAa,MAAM,IAAI,MAAM;AAAoP,GACjR,4HACA;AAEG,MAAM,wBAAwB,IAAA,sTAAuB,EACxD;IAAa,MAAM,IAAI,MAAM;AAA0P,GACvR,4HACA","ignoreList":[0]}},
    {"offset": {"line": 53, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tamar/Desktop/autamubilismo/studio/node_modules/%40mux/mux-player-react/dist/index.mjs/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const MaxResolution = registerClientReference(\n    function() { throw new Error(\"Attempted to call MaxResolution() from the server but MaxResolution is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs\",\n    \"MaxResolution\",\n);\nexport const MediaError = registerClientReference(\n    function() { throw new Error(\"Attempted to call MediaError() from the server but MediaError is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs\",\n    \"MediaError\",\n);\nexport const MinResolution = registerClientReference(\n    function() { throw new Error(\"Attempted to call MinResolution() from the server but MinResolution is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs\",\n    \"MinResolution\",\n);\nexport const RenditionOrder = registerClientReference(\n    function() { throw new Error(\"Attempted to call RenditionOrder() from the server but RenditionOrder is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs\",\n    \"RenditionOrder\",\n);\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs\",\n    \"default\",\n);\nexport const generatePlayerInitTime = registerClientReference(\n    function() { throw new Error(\"Attempted to call generatePlayerInitTime() from the server but generatePlayerInitTime is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs\",\n    \"generatePlayerInitTime\",\n);\nexport const playerSoftwareName = registerClientReference(\n    function() { throw new Error(\"Attempted to call playerSoftwareName() from the server but playerSoftwareName is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs\",\n    \"playerSoftwareName\",\n);\nexport const playerSoftwareVersion = registerClientReference(\n    function() { throw new Error(\"Attempted to call playerSoftwareVersion() from the server but playerSoftwareVersion is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/@mux/mux-player-react/dist/index.mjs\",\n    \"playerSoftwareVersion\",\n);\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,uEAAuE;AACvE;;AACO,MAAM,gBAAgB,IAAA,sTAAuB,EAChD;IAAa,MAAM,IAAI,MAAM;AAA0O,GACvQ,wGACA;AAEG,MAAM,aAAa,IAAA,sTAAuB,EAC7C;IAAa,MAAM,IAAI,MAAM;AAAoO,GACjQ,wGACA;AAEG,MAAM,gBAAgB,IAAA,sTAAuB,EAChD;IAAa,MAAM,IAAI,MAAM;AAA0O,GACvQ,wGACA;AAEG,MAAM,iBAAiB,IAAA,sTAAuB,EACjD;IAAa,MAAM,IAAI,MAAM;AAA4O,GACzQ,wGACA;uCAEW,IAAA,sTAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAA0U,GACvW,wGACA;AAEG,MAAM,yBAAyB,IAAA,sTAAuB,EACzD;IAAa,MAAM,IAAI,MAAM;AAA4P,GACzR,wGACA;AAEG,MAAM,qBAAqB,IAAA,sTAAuB,EACrD;IAAa,MAAM,IAAI,MAAM;AAAoP,GACjR,wGACA;AAEG,MAAM,wBAAwB,IAAA,sTAAuB,EACxD;IAAa,MAAM,IAAI,MAAM;AAA0P,GACvR,wGACA","ignoreList":[0]}},
    {"offset": {"line": 102, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tamar/Desktop/autamubilismo/studio/node_modules/%40mux/mux-player-react/src/index.tsx","file:///C:/Users/tamar/Desktop/autamubilismo/studio/node_modules/%40mux/mux-player-react/src/common/utils.ts","file:///C:/Users/tamar/Desktop/autamubilismo/studio/node_modules/%40mux/mux-player-react/src/useComposedRefs.ts","file:///C:/Users/tamar/Desktop/autamubilismo/studio/node_modules/%40mux/mux-player-react/src/useObjectPropEffect.ts","file:///C:/Users/tamar/Desktop/autamubilismo/studio/node_modules/%40mux/mux-player-react/src/env.ts","file:///C:/Users/tamar/Desktop/autamubilismo/studio/node_modules/%40mux/mux-player-react/src/useEventCallbackEffect.ts"],"sourcesContent":["'use client';\nimport React, { useState, useRef } from 'react';\nimport { MaxResolution, MinResolution, RenditionOrder, generatePlayerInitTime } from '@mux/playback-core';\nimport { MediaError } from '@mux/mux-player';\nimport type MuxPlayerElement from '@mux/mux-player';\nimport type { MuxPlayerElementEventMap } from '@mux/mux-player';\nimport { toNativeProps } from './common/utils';\nimport { useComposedRefs } from './useComposedRefs';\nimport useObjectPropEffect, { defaultHasChanged } from './useObjectPropEffect';\nimport { getPlayerVersion } from './env';\nimport { useEventCallbackEffect } from './useEventCallbackEffect';\nimport type { MuxPlayerProps, MuxPlayerRefAttributes } from './types';\n\nexport { MediaError, MaxResolution, MinResolution, RenditionOrder, generatePlayerInitTime };\nexport * from './types';\n\nconst MuxPlayerInternal = React.forwardRef<MuxPlayerRefAttributes, MuxPlayerProps>(({ children, ...props }, ref) => {\n  return React.createElement(\n    'mux-player',\n    {\n      suppressHydrationWarning: true, // prevent issues with SSR / player-init-time\n      ...toNativeProps(props),\n      ref,\n    },\n    children\n  );\n});\n\nconst usePlayer = (\n  ref: // | ((instance: EventTarget | null) => void)\n  React.MutableRefObject<MuxPlayerElement | null> | null | undefined,\n  props: MuxPlayerProps\n) => {\n  const {\n    onAbort,\n    onCanPlay,\n    onCanPlayThrough,\n    onEmptied,\n    onLoadStart,\n    onLoadedData,\n    onLoadedMetadata,\n    onProgress,\n    onDurationChange,\n    onVolumeChange,\n    onRateChange,\n    onResize,\n    onWaiting,\n    onPlay,\n    onPlaying,\n    onTimeUpdate,\n    onPause,\n    onSeeking,\n    onSeeked,\n    onStalled,\n    onSuspend,\n    onEnded,\n    onError,\n    onCuePointChange,\n    onChapterChange,\n    metadata,\n    tokens,\n    paused,\n    playbackId,\n    playbackRates,\n    currentTime,\n    themeProps,\n    extraSourceParams,\n    castCustomData,\n    _hlsConfig,\n    ...remainingProps\n  } = props;\n  /**\n   * @TODO We need to have some better modeling/architecture around order effects. We should also revisit our mapping of media-request-related props\n   * all to `src` in our template code. For now, moving tokens before playbackId, as there are timing issues that happen if we set it after playbackId (CJP)\n   **/\n  useObjectPropEffect('tokens', tokens, ref);\n  // NOTE: We should set playbackId before all other props to ensure that any playback/view session-specific props are applied to the approrpiate\n  // session. \"Under the hood,\" we wait one frame before (re)initializing playback core (and thus e.g. hls.js and mux-embed data sdk), so everything\n  // should be applied as expected as a result.\n  useObjectPropEffect('playbackId', playbackId, ref);\n  useObjectPropEffect('playbackRates', playbackRates, ref);\n  useObjectPropEffect('metadata', metadata, ref);\n  useObjectPropEffect('extraSourceParams', extraSourceParams, ref);\n  useObjectPropEffect('_hlsConfig', _hlsConfig, ref);\n  useObjectPropEffect('themeProps', themeProps, ref);\n  useObjectPropEffect('castCustomData', castCustomData, ref);\n  useObjectPropEffect(\n    'paused',\n    paused,\n    ref,\n    (playerEl: HTMLMediaElement, pausedVal?: boolean) => {\n      if (pausedVal == null) return;\n      if (pausedVal) {\n        playerEl.pause();\n      } else {\n        playerEl.play();\n      }\n    },\n    (playerEl, value, propName) => {\n      if (playerEl.hasAttribute('autoplay') && !playerEl.hasPlayed) {\n        return false;\n      }\n      return defaultHasChanged(playerEl, value, propName);\n    }\n  );\n  useObjectPropEffect('currentTime', currentTime, ref, (playerEl: HTMLMediaElement, currentTimeVal?: number) => {\n    if (currentTimeVal == null) return;\n    playerEl.currentTime = currentTimeVal;\n  });\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('abort', ref, onAbort);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('canplay', ref, onCanPlay);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('canplaythrough', ref, onCanPlayThrough);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('emptied', ref, onEmptied);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('loadstart', ref, onLoadStart);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('loadeddata', ref, onLoadedData);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('loadedmetadata', ref, onLoadedMetadata);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('progress', ref, onProgress);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('durationchange', ref, onDurationChange);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('volumechange', ref, onVolumeChange);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('ratechange', ref, onRateChange);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('resize', ref, onResize);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('waiting', ref, onWaiting);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('play', ref, onPlay);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('playing', ref, onPlaying);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('timeupdate', ref, onTimeUpdate);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('pause', ref, onPause);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('seeking', ref, onSeeking);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('seeked', ref, onSeeked);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('stalled', ref, onStalled);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('suspend', ref, onSuspend);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('ended', ref, onEnded);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('error', ref, onError);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('cuepointchange', ref, onCuePointChange);\n  useEventCallbackEffect<MuxPlayerElement, MuxPlayerElementEventMap>('chapterchange', ref, onChapterChange);\n  return [remainingProps];\n};\n\nexport const playerSoftwareVersion = getPlayerVersion();\nexport const playerSoftwareName = 'mux-player-react';\n\nconst MuxPlayer = React.forwardRef<\n  MuxPlayerRefAttributes,\n  Omit<MuxPlayerProps, 'playerSoftwareVersion' | 'playerSoftwareName'>\n>((props, ref) => {\n  const innerPlayerRef = useRef<MuxPlayerElement>(null);\n  const playerRef = useComposedRefs(innerPlayerRef, ref);\n  const [remainingProps] = usePlayer(innerPlayerRef, props);\n  const [playerInitTime] = useState(props.playerInitTime ?? generatePlayerInitTime());\n\n  return (\n    <MuxPlayerInternal\n      /** @TODO Fix types relationships (CJP) */\n      ref={playerRef as React.Ref<MuxPlayerElement>}\n      defaultHiddenCaptions={props.defaultHiddenCaptions}\n      playerSoftwareName={playerSoftwareName}\n      playerSoftwareVersion={playerSoftwareVersion}\n      playerInitTime={playerInitTime}\n      {...remainingProps}\n    />\n  );\n});\n\nexport default MuxPlayer;\n","import React from 'react';\n\n// React 19 supports custom elements and setting properties directly on them,\n// older React versions converted all props to attributes on custom elments.\n// Boolean `true` values should not be converted to empty strings in React 19+\n// because that would result in a `false` value if it was set via a property.\n// React 19+ handles primitive values correctly but we still need to convert\n// the camelCase prop names to kebab-case attribute names for mux-player. (WL)\n\nconst IS_REACT_19_OR_NEWER = parseInt(React.version) >= 19;\n\n// NOTE: As a forward-looking implementation, we may want to assume\n// prop names -> attribute names is always a simple name.toLowerCase()\n// and provide a mechanism for passing in per-component overrides for\n// e.g. kebab cases, as that's the way React/Preact handles these. (CJP)\nconst ReactPropToAttrNameMap = {\n  className: 'class',\n  classname: 'class',\n  htmlFor: 'for',\n  crossOrigin: 'crossorigin',\n  viewBox: 'viewBox',\n  playsInline: 'playsinline',\n  autoPlay: 'autoplay',\n  playbackRate: 'playbackrate',\n};\n\ntype KeyTypes = string | number | symbol;\ntype Maybe<T> = T | null | undefined;\n\nexport const isNil = (x: unknown): x is null | undefined => x == undefined;\n\n// Type Guard to determine if a given key is actually a key of some object of type T\nexport const isKeyOf = <T extends object = any>(k: KeyTypes, o: Maybe<T>): k is keyof T => {\n  if (isNil(o)) return false;\n  return k in o;\n};\n\nconst toKebabCase = (string: string) => string.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n\nexport const toNativeAttrName = (propName: string, propValue: any): string | undefined => {\n  if (!IS_REACT_19_OR_NEWER && typeof propValue === 'boolean' && !propValue) return undefined;\n  if (isKeyOf(propName, ReactPropToAttrNameMap)) return ReactPropToAttrNameMap[propName];\n  if (typeof propValue === 'undefined') return undefined;\n  if (/[A-Z]/.test(propName)) return toKebabCase(propName);\n  return propName;\n};\nexport const toStyleAttr = <T>(x: T) => x;\n\nexport const toNativeAttrValue = (propValue: any, _propName: string) => {\n  if (!IS_REACT_19_OR_NEWER && typeof propValue === 'boolean') return '';\n  return propValue;\n};\n\nexport const toNativeProps = (props: { ref?: any; [key: string]: any } = {}) => {\n  const { ref, ...restProps } = props;\n  return Object.entries(restProps).reduce<{ [k: string]: string }>((transformedProps, [propName, propValue]) => {\n    const attrName = toNativeAttrName(propName, propValue);\n\n    // prop was stripped. Don't add.\n    if (!attrName) {\n      return transformedProps;\n    }\n\n    const attrValue = toNativeAttrValue(propValue, propName);\n    transformedProps[attrName] = attrValue;\n    return transformedProps;\n  }, {});\n};\n","import * as React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T): (() => void) | void | undefined {\n  if (typeof ref === 'function') {\n    return ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    (ref as React.MutableRefObject<T>).current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup == 'function') {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup == 'function') {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n","import { useEffect } from 'react';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Slightly modified version of React's shallowEqual, with optimizations for Arrays\n * so we may treat them specifically as unequal if they are not a) both arrays\n * or b) don't contain the same (shallowly compared) elements.\n */\nconst shallowEqual = (objA: any, objB: any): boolean => {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  if (Array.isArray(objA)) {\n    // Early \"cheap\" array compares\n    if (!Array.isArray(objB) || objA.length !== objB.length) return false;\n    // Shallow compare for arrays\n    return objA.some((vVal, i) => objB[i] === vVal);\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (let i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport const defaultHasChanged = (obj: any, v: any, k: string) => {\n  return !shallowEqual(v, obj[k]);\n};\n\nconst defaultUpdateValue = (obj: any, v: any, k: string) => {\n  obj[k] = v;\n};\n\nexport const useObjectPropEffect = <T extends { [k: string]: any }, V>(\n  propName: string,\n  propValue: V | null | undefined,\n  ref: React.MutableRefObject<T | null> | null | undefined,\n  updateValue = defaultUpdateValue,\n  hasChanged = defaultHasChanged\n) => {\n  return useEffect(() => {\n    const obj = ref?.current;\n    if (!obj) return;\n    if (!hasChanged(obj, propValue, propName)) return;\n    updateValue(obj, propValue, propName);\n  }, [ref?.current, propValue]);\n};\n\nexport default useObjectPropEffect;\n","const getEnvPlayerVersion = () => {\n  try {\n    // @ts-ignore\n    return PLAYER_VERSION as string;\n  } catch {}\n  return 'UNKNOWN';\n};\n\nconst player_version: string = getEnvPlayerVersion();\n\nexport const getPlayerVersion = () => player_version;\n","import React, { useEffect } from 'react';\nimport type { GenericEventListener } from './index';\n\nexport const useEventCallbackEffect = <\n  TElement extends EventTarget = EventTarget,\n  TEventMap extends Record<string, Event> = Record<string, Event>,\n  K extends keyof TEventMap = keyof TEventMap,\n>(\n  type: K,\n  ref: // | ((instance: EventTarget | null) => void)\n  React.MutableRefObject<TElement | null> | null | undefined,\n  callback: GenericEventListener<TEventMap[K]> | undefined\n) => {\n  return useEffect(() => {\n    const eventTarget = ref?.current;\n    if (!eventTarget || !callback) return;\n\n    // Type assertion needed because TypeScript can't infer the exact event type\n    const eventName = type as string;\n    const listener = callback as EventListener;\n\n    eventTarget.addEventListener(eventName, listener);\n    return () => {\n      eventTarget.removeEventListener(eventName, listener);\n    };\n  }, [ref?.current, callback, type]);\n};\n"],"names":["React", "useState", "useRef", "MaxResolution", "MinResolution", "RenditionOrder", "generatePlayerInitTime", "MediaError", "React", "IS_REACT_19_OR_NEWER", "ReactPropToAttrNameMap", "isNil", "x", "isKeyOf", "k", "o", "toKebabCase", "string", "match", "toNativeAttrName", "propName", "propValue", "toNativeAttrValue", "propValue", "_propName", "IS_REACT_19_OR_NEWER", "toNativeProps", "props", "ref", "restProps", "transformedProps", "propName", "attrName", "toNativeAttrName", "attrValue", "React", "setRef", "ref", "value", "composeRefs", "refs", "node", "hasCleanup", "cleanups", "cleanup", "i", "useComposedRefs", "useEffect", "hasOwnProperty", "shallowEqual", "objA", "objB", "vVal", "i", "keysA", "keysB", "defaultHasChanged", "obj", "v", "k", "defaultUpdateValue", "useObjectPropEffect", "propName", "propValue", "ref", "updateValue", "hasChanged", "useObjectPropEffect_default", "getEnvPlayerVersion", "player_version", "getPlayerVersion", "useEffect", "useEventCallbackEffect", "type", "ref", "callback", "eventTarget", "eventName", "listener", "MuxPlayerInternal", "React", "children", "props", "ref", "toNativeProps", "usePlayer", "onAbort", "onCanPlay", "onCanPlayThrough", "onEmptied", "onLoadStart", "onLoadedData", "onLoadedMetadata", "onProgress", "onDurationChange", "onVolumeChange", "onRateChange", "onResize", "onWaiting", "onPlay", "onPlaying", "onTimeUpdate", "onPause", "onSeeking", "onSeeked", "onStalled", "onSuspend", "onEnded", "onError", "onCuePointChange", "onChapterChange", "metadata", "tokens", "paused", "playbackId", "playbackRates", "currentTime", "themeProps", "extraSourceParams", "castCustomData", "_hlsConfig", "remainingProps", "useObjectPropEffect_default", "playerEl", "pausedVal", "value", "propName", "defaultHasChanged", "currentTimeVal", "useEventCallbackEffect", "playerSoftwareVersion", "getPlayerVersion", "playerSoftwareName", "MuxPlayer", "_a", "innerPlayerRef", "useRef", "playerRef", "useComposedRefs", "playerInitTime", "useState", "generatePlayerInitTime", "index_default"],"mappings":""}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Users/tamar/Desktop/autamubilismo/studio/node_modules/sanity/lib/_chunks-es/VideoPlayer.js","sources":["file:///C:/Users/tamar/Desktop/autamubilismo/studio/node_modules/sanity/src/media-library/plugin/VideoInput/VideoPlayer.tsx"],"sourcesContent":["// oxlint-disable-next-line no-unassigned-import -- style import is effectful\nimport 'player.style/sutro'\n\nimport MuxPlayer from '@mux/mux-player-react'\n\nimport {type VideoPlaybackTokens} from './types'\n\ntype VideoPlayerProps = {\n  customDomain: string\n  playbackId: string\n  aspectRatio?: number\n  tokens?: VideoPlaybackTokens\n}\n\nexport function VideoPlayer({customDomain, playbackId, tokens, aspectRatio}: VideoPlayerProps) {\n  return (\n    <MuxPlayer\n      customDomain={customDomain}\n      theme={'sutro' as const}\n      playbackId={playbackId}\n      tokens={tokens}\n      autoPlay={false}\n      loop={false}\n      style={{\n        position: 'absolute',\n        inset: 0,\n      }}\n    />\n  )\n}\n"],"names":["VideoPlayer","t0","$","_c","customDomain","playbackId","tokens","t1","for","position","inset","t2"],"mappings":";;;;;;;;;;AAcO,SAAAA,YAAAC,EAAAA,EAAA;IAAA,MAAAC,QAAAC,+QAAAA,EAAA,CAAA,GAAqB,EAAAC,YAAAA,EAAAC,UAAAA,EAAAC,MAAAA,EAAAA,GAAAL;IAAiE,IAAAM;IAAAL,CAAAA,CAAA,CAAA,CAAA,KAAA,aAAA,GAAA,OAAAM,GAAAA,CAAA,2BAAA,IAAA,CAShFD,KAAA;QAAAE,UACK;QAAUC,OACb;IAAA,GACRR,CAAAA,CAAAA,EAAAA,GAAAK,EAAAA,IAAAA,KAAAL,CAAAA,CAAA,CAAA,CAAA;IAAA,IAAAS;IAAA,OAAAT,CAAAA,CAAA,CAAA,CAAA,KAAAE,gBAAAF,CAAAA,CAAAA,EAAAA,KAAAG,cAAAH,CAAAA,CAAA,CAAA,CAAA,KAAAI,SAAAA,CAVHK,KAAAA,aAAAA,GAAAA,IAAAA,4QAAAA,EAAC,oOAAA,EAAA;QACeP;QACP,OAAA;QACKC;QACJC;QACE,UAAA,CAAA;QACJ,MAAA,CAAA;QACC,OAAAC;IAAAA,CAGN,GACDL,CAAAA,CAAAA,EAAAA,GAAAE,cAAAF,CAAAA,CAAAA,EAAAA,GAAAG,YAAAH,CAAAA,CAAAA,EAAAA,GAAAI,QAAAJ,CAAAA,CAAAA,EAAAA,GAAAS,EAAAA,IAAAA,KAAAT,CAAAA,CAAA,CAAA,CAAA,EAXFS;AAWE"}}]
}